{
    "contents" : "setwd(\"C:\\\\xtang\\\\workspace\\\\mystockAnalysis\")\nlibrary(sqldf)\nlibrary(RCurl)\nlibrary(quantmod)\nlibrary(plyr)\nlibrary(logging)\nlibrary(futile.logger)\nlibrary(base)\nflog.threshold(DEBUG) \n\n#file <- readRXSJFile(\"C:\\\\xtang\\\\workspace\\\\R\\\\stockAnalysis\\\\rxsj\\\\000001.txt\")\n#partingDataDF[order(as.Date(partingDataDF$日期,format=\"%d/%m/%Y\")),]\n\nSys.setenv(http_proxy=\"http://child-prc.intel.com:913\")\nhistoryTradeLink <- \"http://market.finance.sina.com.cn/downxls.php?date=2015-09-21&symbol=sz300205\"\n#download.file(historyTradeLink,destfile=\".\\\\test.xlsx\")\n\n#读取日线数据\nrxsj_col_names <- c(\"日期\",\"开盘\",\"最高\",\"最低\",\"收盘\",\"成交量\",\"成交额\")\nrxsj_colClasses <- c(\"Date\",\"numeric\",\"numeric\",\"numeric\",\"numeric\",\"numeric\",\"numeric\")\nreadRXSJFile <- function(filename) {\n  lines <- length(readLines(filename)) \n  #print(lines-3)\n  fileDF <- read.csv(filename,sep=\",\", header=FALSE,skip=2,nrows=(lines-3),col.names=rxsj_col_names,colClasses=rxsj_colClasses)\n  return(fileDF)\n}\n\ngetAllRXSJFiles <- function() {\n  wd <- getwd()\n  filePath <- paste(wd,\"//rxsj\",sep=\"\") \n  files <- list.files(filePath)\n  return(files)\n}\n\ncalculateTopParting <- function(origData,startDate,endDate) {\n  flog.debug(\"--------------------------------------------------------------------\")\n  flog.debug(paste(\"calculate date between\",startDate,\"and\",endDate))\n  \n  partingDataDF <- data.frame(\n    日期 = as.Date(character(\"0\")),\n    开盘 = numeric(0),\n    最高 = numeric(0),\n    最低 = numeric(0),\n    收盘 = numeric(0),\n    成交量 = numeric(0),\n    成交额 = numeric(0)) \n  \n  sDate <- as.Date(startDate)\n  start <- -1\n  eDate <- as.Date(endDate)\n  end <- -1\n  \n  if ((sDate + 2) > eDate) {\n    flog.debug(paste(\"the start date\",startDate,\"is less than\",endDate,\"- 3 \"))\n    return(NULL)\n  }\n  \n  \n  len <- nrow(origData)\n  lastDate <- as.Date(origData[len,1])\n  flog.debug(paste(\"lastDate\",lastDate))\n  while(eDate > sDate) {\n    end <- which(origData$日期 == eDate)\n    if(length(end)!=0) {\n      if(eDate != as.Date(endDate)) {\n        flog.warn(paste(\"WARNING:shift end date from\",endDate,\"to\",eDate))  \n      }      \n      break\n    } \n    eDate <- eDate-1   \n  }\n  \n#   shiftDate2LeftIfNa(origData,eDate,sDate)\n#   flog.debug(paste(\"after shift to left the eDdate is\",eDate))\n  flog.debug(paste(\"1 sDate\",sDate,\"eDate\",eDate))\n  while(sDate < eDate) {\n    start <- which(origData$日期 == sDate)\n    if(length(start)!=0) {\n      if(sDate != as.Date(startDate)) {\n        flog.warn(paste(\"WARNING:shift start date from\",startDate,\"to\",sDate))\n      }      \n      break\n    } \n    sDate <- sDate + 1\n  }\n  flog.debug(paste(\"2 sDate\",sDate,\"eDate\",eDate))\n#   shiftDate2RightIfNa(origData,sDate,eDate)\n#   flog.debug(paste(\"after shift to right the sDdate is\",sDate))\n  \n  if(sDate == eDate) {\n    flog.debug(paste(\"can not find start date\",startDate))\n    return(NULL)\n  }\n  #subset according to duration\n  subData <- subset(origData,origData$日期>=sDate & origData$日期<= eDate,na.rm = TRUE)\n  flog.debug(paste(\"length subdata:\",nrow(subData)))\n  #get high price in the duration\n  highestPrice <- max(subData$最高,na.rm = TRUE)\n  #subset according to the high price\n  highestData <- subset(subData,subData$最高==highestPrice)\n  highDate <- highestData[1,1]\n\n  # if the highest price reaches most left or most right, it is not the parting\n  highDate <- as.Date(highestData[1,1])\n  flog.debug(paste(\"highDate:\",highDate))\n  flog.debug(paste(\"subData[1,1]:\",subData[1,1]))\n  flog.debug(paste(\"subData[,1]:\",subData[length(subData[,1]),1]))\n  if(highDate == subData[length(subData[,1]),1]) {\n    flog.info(paste(\"the highest price date reaches most right. most left:\",subData[1,1],\"highDate:\",highDate,\"most right:\",subData[length(subData[,1]),1]))\n    #pathToLeftFirstLowestPrice(subData,)\n    return(calculateTopParting(subData,sDate,highDate-1))\n  }\n   \n  if(highDate == subData[1,1]) {\n    flog.info(paste(\"the highest price date reaches most left. most left:\",subData[1,1],\"highDate:\",highDate,\"most right:\",subData[length(subData[,1]),1]))\n    #return(calculateTopParting(id,subData,sDate-1,highDate))\n    return(calculateTopParting(subData,highDate+1,eDate))\n  }\n\n  #check if the highest price date is already record\n  inds <- which(partingDataDF$日期==highDate)\n  if(length(inds) == 0) {\n    #partingDataDF <- c(partingDataDF, highDate)\n    #assign(\"partingDataDF\", rbind(partingDataDF,highestData), envir = .GlobalEnv)\n    \n#     highDateInds <- which(subData$日期 == highDate)\n#     leftHightDateInds <- highDateInds - 1\n#     rightHightDateInds <- highDateInds + 1\n#     \n# #     if (subData[leftHightDateInds,]$最低 < highestData$最低 \n# #         && subData[rightHightDateInds,]$最低 < highestData$最低) {\n# #      \n# #     }\n    partingDataDF <- rbind(partingDataDF,highestData)\n    partingDataDF <- partingDataDF[order(as.Date(partingDataDF$日期,format=\"%d/%m/%Y\")),]\n    flog.debug(paste(\"partingDataDF$日期\",partingDataDF[1,1]))\n    flog.info(paste(\"insert highest date\",highDate)) \n  } else {\n    flog.error(paste(\"find the same high date\",highDate,\"between\",sDate,\"and\",eDate))\n    return(NULL)\n  }\n\n#   while(!is.null(calculateTopParting(id,subData,sDate,highDate-1))) {\n#     \n#   }\n  newDf <- calculateTopParting(subData,sDate,highDate-1)\n  partingDataDF <- rbind(partingDataDF,newDf)\n  partingDataDF <- partingDataDF[order(as.Date(partingDataDF$日期,format=\"%d/%m/%Y\")),]\n\n  newDf <- calculateTopParting(subData,highDate+1,eDate)\n  partingDataDF <- rbind(partingDataDF,newDf)\n  partingDataDF <- partingDataDF[order(as.Date(partingDataDF$日期,format=\"%d/%m/%Y\")),]  \n\n  return(partingDataDF)\n}\n\n\ncalculateBottomParting <- function(origData,startDate,endDate) {\n  flog.debug(\"--------------------------------------------------------------------\")\n  flog.debug(paste(\"calculate bottom parting date between\",startDate,\"and\",endDate))\n  \n  partingDataDF <- data.frame(\n    日期 = as.Date(character(\"0\")),\n    开盘 = numeric(0),\n    最高 = numeric(0),\n    最低 = numeric(0),\n    收盘 = numeric(0),\n    成交量 = numeric(0),\n    成交额 = numeric(0))  \n  \n  sDate <- as.Date(startDate)\n  start <- -1\n  eDate <- as.Date(endDate)\n  end <- -1\n  \n  if ((sDate + 2) > eDate) {\n    flog.debug(paste(\"the start date\",startDate,\"is less than\",endDate,\"- 3 \"))\n    return(NULL)\n  }\n  \n  \n  len <- nrow(origData)\n  lastDate <- as.Date(origData[len,1])\n  flog.debug(paste(\"lastDate\",lastDate))\n  while(eDate > sDate) {\n    end <- which(origData$日期 == eDate)\n    if(length(end)!=0) {\n      if(eDate != as.Date(endDate)) {\n        flog.warn(paste(\"WARNING:shift end date from\",endDate,\"to\",eDate))  \n      }      \n      break\n    } \n    eDate <- eDate-1   \n  }\n  \n  #   shiftDate2LeftIfNa(origData,eDate,sDate)\n  #   flog.debug(paste(\"after shift to left the eDdate is\",eDate))\n  flog.debug(paste(\"1 sDate\",sDate,\"eDate\",eDate))\n  while(sDate < eDate) {\n    start <- which(origData$日期 == sDate)\n    if(length(start)!=0) {\n      if(sDate != as.Date(startDate)) {\n        flog.warn(paste(\"WARNING:shift start date from\",startDate,\"to\",sDate))\n      }      \n      break\n    } \n    sDate <- sDate + 1\n  }\n  flog.debug(paste(\"2 sDate\",sDate,\"eDate\",eDate))\n  #   shiftDate2RightIfNa(origData,sDate,eDate)\n  #   flog.debug(paste(\"after shift to right the sDdate is\",sDate))\n  \n  if(sDate == eDate) {\n    flog.debug(paste(\"can not find start date\",startDate))\n    return(NULL)\n  }\n  #subset according to duration\n  subData <- subset(origData,origData$日期>=sDate & origData$日期<= eDate,na.rm = TRUE)\n  flog.debug(paste(\"length subdata:\",nrow(subData)))\n  #get low price in the duration\n  lowestPrice <- min(subData$最低,na.rm = TRUE)\n  #subset according to the low price\n  lowestData <- subset(subData,subData$最低==lowestPrice)\n  lowDate <- lowestData[1,1]\n  \n  # if the lowest price reaches most left or most right, it is not the parting\n  lowDate <- as.Date(lowestData[1,1])\n  flog.debug(paste(\"lowDate:\",lowDate))\n  flog.debug(paste(\"subData[1,1]:\",subData[1,1]))\n  flog.debug(paste(\"subData[,1]:\",subData[length(subData[,1]),1]))\n  if(lowDate == subData[length(subData[,1]),1]) {\n    flog.info(paste(\"the lowest price date reaches most right. most left:\",subData[1,1],\"lowDate:\",lowDate,\"most right:\",subData[length(subData[,1]),1]))\n    return(calculateBottomParting(subData,sDate,lowDate-1))\n  }\n  \n  if(lowDate == subData[1,1]) {\n    flog.info(paste(\"the lowest price date reaches most left. most left:\",subData[1,1],\"lowDate:\",lowDate,\"most right:\",subData[length(subData[,1]),1]))\n    return(calculateBottomParting(subData,lowDate+1,eDate))\n  }\n  \n  #check if the lowest price date is already record\n  inds <- which(partingDataDF$日期==lowDate)\n  if(length(inds) == 0) {\n    #partingDataDF <- c(partingDataDF, lowDate)\n    #assign(\"partingDataDF\", rbind(partingDataDF,lowestData), envir = .GlobalEnv)\n    \n#     lowDateInds <- which(subData$日期 == lowDate)\n#     leftLowDateInds <- lowDateInds - 1\n#     rightLowDateInds <- lowDateInds + 1\n#     \n# #     if (subData[leftLowDateInds,]$最高 > lowestData$最高 \n# #         && subData[rightLowDateInds,]$最高 > lowestData$最高) {\n# #       \n# #     }\n    partingDataDF <- rbind(partingDataDF,lowestData)\n    partingDataDF <- partingDataDF[order(as.Date(partingDataDF$日期,format=\"%d/%m/%Y\")),]\n    flog.debug(paste(\"partingDataDF$日期\",partingDataDF$日期))\n    flog.info(paste(\"insert lowest date\",lowDate))    \n\n  } else {\n    flog.error(paste(\"find the same low date\",lowDate,\"between\",sDate,\"and\",eDate))\n    return(NULL)\n  }\n  \n#   while(!is.null(calculateBottomParting(id,subData,sDate,lowDate-1))) {\n#     \n#   }\n  newdf <- calculateBottomParting(subData,sDate,lowDate-1)\n  partingDataDF <- rbind(partingDataDF,newdf)\n  partingDataDF <- partingDataDF[order(as.Date(partingDataDF$日期,format=\"%d/%m/%Y\")),]    \n  \n#   while(!is.null(calculateBottomParting(id,subData,lowDate+1,eDate))) {\n#     \n#   }\n#   \n  newdf <- calculateBottomParting(subData,lowDate+1,eDate)\n  partingDataDF <- rbind(partingDataDF,newdf)\n  partingDataDF <- partingDataDF[order(as.Date(partingDataDF$日期,format=\"%d/%m/%Y\")),]\n\n  return(partingDataDF)\n}\n\nvalidateBottomPartingType <- function(totalDataDF,bottom) {\n  botLeftDate <- bottom[1,1] - 1\n  oLeftDate <- botLeftDate \n\n  inds <- -1\n  while(botLeftDate > totalDataDF[1,1]) {\n    inds <- which(totalDataDF$日期 == botLeftDate)\n    if(length(inds)!=0) {\n      if(botLeftDate != as.Date(oLeftDate)) {\n        flog.warn(paste(\"WARNING:shift left date from\",oLeftDate,\"to\",botLeftDate))  \n      }      \n      break\n    } \n    botLeftDate <- botLeftDate-1   \n  }  \n  \n  if(length(inds) == 0) {\n    flog.warn(paste(\"the bottom left date\",botLeftDate,\"is not found in total data\"))\n    return(FALSE)\n  }\n  botLeftLowPrice <- totalDataDF$最低[inds]\n  \n  botRightDate <- bottom[1,1] + 1\n  oRightDate <- botRightDate\n  \n  inds <- -1\n  while(botRightDate < totalDataDF[nrow(totalDataDF),1]) {\n    inds <- which(totalDataDF$日期 == botRightDate)\n    if(length(inds)!=0) {\n      if(botRightDate != as.Date(oRightDate)) {\n        flog.warn(paste(\"WARNING:shift left date from\",oRightDate,\"to\",botRightDate))  \n      }      \n      break\n    } \n    botRightDate <- botRightDate+1   \n  }   \n  \n  if(length(inds) == 0) {\n    flog.warn(paste(\"the bottom right date\",botRightDate,\"is not found in total data\"))\n    return(FALSE)\n  }     \n  botRightLowPrice <- totalDataDF$最低[inds]\n  \n  bottomLowPrice <- bottom$最低[1]\n  flog.debug(paste(\"check botLeftLowPrice\",botLeftLowPrice,\"bottomLowPrice\",bottomLowPrice,\"botRightDate\",botRightDate))\n  \n  if(min(botLeftLowPrice,bottomLowPrice,botRightLowPrice) != bottomLowPrice) {\n    flog.error(paste(\"the bottomLowDate\",bottom[1,1],\"is not the bottom parting, check failed!\"))\n    return(FALSE)\n  }\n  return(TRUE)\n}\n\nvalidateLowPriceBetweenTwoBtm <- function(totalDataDF,leftBot,rightBot) {\n  leftBotDate <- leftBot[1,1]\n  inds <- which(totalDataDF$日期 == leftBotDate)\n  if(length(inds) == 0) {\n    flog.warn(paste(\"the leftBotDate date\",leftBotDate,\"is not found in total data\"))\n    return(FALSE)\n  }\n  \n  rightBotDate <- rightBot[1,1]\n  inds <- which(totalDataDF$日期 == rightBotDate)\n  if(length(inds) == 0) {\n    flog.warn(paste(\"the rightBotDate date\",rightBot,\"is not found in total data\"))\n    return(FALSE)\n  }\n  \n  df <- calculateBottomParting(totalDataDF,leftBotDate,rightBotDate)\n  if(!is.null(df)) {\n    flog.error(paste(\"there is another bottom parting\",df[1,1],\"between\",leftBotDate,\"and\",rightBotDate,\", check failed!\"))\n    return(FALSE)\n  }\n  return(TRUE)\n}\n\nvalidateBottomParting <- function(totalDataDF,bottomPartingDF) {\n  for(i in 1:nrow(bottomPartingDF)) {\n    bot1 <- bottomPartingDF[i,]\n    bot1Date <- bot1[1,1]\n    flog.debug(paste(\"check bottom parting\",bot1Date))\n    inds <- which(totalDataDF$日期 == bot1Date)\n    if(length(inds) == 0) {\n      flog.warn(paste(\"the bottom parting\",bot1Date,\"is not found in total data\"))\n      return(FALSE)\n    }\n    \n    \n    i <- i + 1\n    if(i >nrow(bottomPartingDF)) {\n      break\n    }\n    \n    \n    bot2 <- bottomPartingDF[i,]\n    bot2Date <- bot2[1,1]\n    flog.debug(paste(\"check bottom parting\",bot2Date))\n    inds <- which(totalDataDF$日期 == bot2Date)\n    if(length(inds) == 0) {\n      flog.warn(paste(\"the bottom parting\",bot2Date,\"is not found in total data\"))\n      return(FALSE)\n    }\n    \n    if(!(validateBottomPartingType(totalDataDF,bot1)\n         && validateLowPriceBetweenTwoBtm(totalDataDF,bot1,bot2))) {\n      flog.error(paste(\"check bottom parting\",bot1Date,\"failed\"))\n      return(FALSE)\n    }\n  }\n  return(TRUE)\n}\n\nfindParting <- function(df,startDate=as.Date(character(0)),endDate=as.Date(character(0))) {\n  topParting <- calculateTopParting(df,startDate,endDate)\n  topParting <- addOneColToDF(topParting,\"收盘\",c(TRUE),\"顶分型\")\n#   print(topParting)\n  \n  bottomParting <- calculateBottomParting(df,startDate,endDate)\n  bottomParting <- addOneColToDF(bottomParting,\"收盘\",c(FALSE),\"顶分型\")\n#   print(bottomParting)\n  \n  partingDataDF <- rbind(topParting,bottomParting)\n  partingDataDF <- partingDataDF[order(as.Date(partingDataDF$日期,format=\"%d/%m/%Y\")),]\n  return(partingDataDF)\n}\n\nshiftDateToLeftIfNA <- function(df,date) {\n  inds <- -1 \n  oDate <- date\n  while(date >= df[1,1]) {\n    inds <- which(df$日期 == date)\n    if(length(inds)!=0) {\n      if(date != as.Date(oDate)) {\n        flog.warn(paste(\"WARNING:shift date to left from\",oDate,\"to\",date))  \n      }      \n      return(inds)\n    } \n    date <- date-1  \n  }\n  return(inds)\n}\n\nshiftDateToRightIfNA <- function(df,date) {\n  inds <- -1 \n  oDate <- date\n  while(date <= df[nrow(df),1]) {\n    inds <- which(df$日期 == date)\n    if(length(inds)!=0) {\n      if(date != as.Date(oDate)) {\n        flog.warn(paste(\"WARNING:shift date to right from\",oDate,\"to\",date))  \n      }      \n      return(inds)\n    } \n    date <- date+1  \n  }\n  return(inds)\n}\n\n\n#根据分型数据处理包含关系\nprocessInclusion <- function(partingDataDF=data.frame(),origDataDF=data.frame(),startDate=NULL,endDate=NULL) {\n  if(is.null(startDate)) {\n    startDate <- origDataDF[1,1]\n  } \n  \n  if (is.null(endDate)) {\n    endDate <- origDataDF[nrow(origDataDF),1]\n  }\n  \n  flog.debug(paste(\"check date between\",startDate,\"and\",endDate))  \n  \n  startInds <- which(origDataDF$日期 == startDate)\n  if(length(startInds) == 0) {\n    flog.error(paste(\"can not find sart date\",startDate))\n    return(NULL)\n  }\n\n  endInds <- which(origDataDF$日期 == endDate)\n  if(length(endInds) == 0) {\n    flog.error(paste(\"can not find end date\",endDate))\n    return(NULL)\n  }\n  \n  emptyDF <- data.frame(\n    日期 = as.Date(character(\"0\")),\n    开盘 = numeric(0),\n    最高 = numeric(0),\n    最低 = numeric(0),\n    收盘 = numeric(0),\n    顶分型 = logical(),\n    成交量 = numeric(0),\n    成交额 = numeric(0))\n  \n  \n  \n  #regionData <- subset(origDataDF,origDataDF$日期 >= startDate && origDataDF$日期 <= endDate)\n  \n  for(i in 1:nrow(partingDataDF)) {\n    candiInds <- c()\n    combinedDataDF <- emptyDF\n    date <- partingDataDF[i,1]\n    highestPrice <- partingDataDF[i,3]\n    lowestPrice <- partingDataDF[i,4]\n    isTopParting <- partingDataDF[i,6]\n    \n    flog.debug(paste(\"check\",date,\"by\",highestPrice,\"and\",lowestPrice,\"with isTopParting\",isTopParting))\n    \n    inds <- which(origDataDF$日期 == date)\n    if (length(inds) == 0) {\n      flog.error(paste(\"can not find date\",date))\n      return(NULL)\n    }\n    \n    if (length(inds) > 1) {\n      flog.error(paste(\"find more than one date\",inds))\n      return(NULL)      \n    }\n    \n    flog.debug(paste(\"inds\",inds,\"startInds\",startInds,\"endInds\",endInds))\n    #subData <- subset(origDataDF, origDataDF$最低 >= lowestPrice & origDataDF$最高 <= highestPrice)\n    subData <- subset(origDataDF, (origDataDF$最低 >= lowestPrice & origDataDF$最高 <= highestPrice) | \n                        (origDataDF$收盘 >= 2293 & origDataDF$开盘 <= 2347) | (origDataDF$开盘 >= 2293 & origDataDF$收盘 <= 2347))\n\n    #     subDataPlots <- which(origDataDF$日期 == subData$日期)\n    #     flog.debug(paste(\"subDataPlots:\",subDataPlots))\n    \n    #print(subData)\n\n    if (nrow(subData) > 1) {\n      j <- 1\n      subDataPlots <- c()\n      while(j < nrow(subData)) {\n        sbdp <- which(origDataDF$日期 == subData[j,]$日期)\n        if(length(sbdp) == 0) {\n          flog.error(paste(\"can not find\",subData[j,]$日期))\n          return(NULL)\n        }\n        flog.debug(paste(\"sbdp\",sbdp,\"date\",origDataDF[sbdp,1],\"highprice\",origDataDF[sbdp,3],\"lowprice\",origDataDF[sbdp,4]))\n        subDataPlots <- c(subDataPlots,sbdp)\n        j<-j+1\n      }\n      #flog.debug(paste(\"subDataPlots:\",subDataPlots))\n      #print(subDataPlots)\n      \n      if(length(subDataPlots) > 1) {\n        partingPlot <- which(subData$日期 == date)\n        flog.debug(paste(\"partingPlot\",partingPlot,\"for date\",date))\n        \n        testPlot <- inds - 1\n        while(testPlot %in% subDataPlots) {\n          flog.debug(paste(\"add left candidate plot\",testPlot))\n          candiInds <- c(candiInds,testPlot)\n          combinedDataDF <- rbind(combinedDataDF,origDataDF[testPlot,])\n          testPlot <- testPlot - 1\n        }\n        \n        testPlot <- inds + 1\n        while(testPlot %in% subDataPlots) {\n          flog.debug(paste(\"add right candidate plot\",testPlot))\n          candiInds <- c(candiInds,testPlot)\n          combinedDataDF <- rbind(combinedDataDF,origDataDF[testPlot,])\n          testPlot <- testPlot + 1\n        }\n                \n        flog.debug(paste(\"candidate inds:\",candiInds,\"for\",inds))\n        if(length(candiInds) > 0) {\n          combinedDataDF <- combinedDataDF[order(as.Date(combinedDataDF$日期,format=\"%d/%m/%Y\")),]\n          print(combinedDataDF)\n          if(isTopParting) {\n            highestLowPrice <- max(combinedDataDF[,4])\n            flog.warn(paste(\"set the date\",origDataDF[inds,1],\" original low price\",origDataDF[inds,4],\"to\",highestLowPrice))\n            origDataDF[inds,4] <- highestLowPrice\n          } else {\n            lowestHighPrice <- min(combinedDataDF[,3])\n            flog.warn(paste(\"set the date\",origDataDF[inds,1],\" original high price\",origDataDF[inds,3],\"to\",lowestHighPrice))\n            origDataDF[inds,3] <- lowestHighPrice            \n          }\n          \n          for(i in 1:length(candiInds)) {            \n            flog.warn(paste(\"set the date\",as.Date(origDataDF[candiInds[i],1]),\"value to NA\"))\n            origDataDF[candiInds[i],2:ncol(origDataDF)] <- NA\n            flog.debug(origDataDF[candiInds[i],])\n          }# end for\n        }#end if\n      }#end if      \n    }#end if\n    \n    i <- i + 1\n  }\n  origDataDF <- na.omit(origDataDF)\n  return(origDataDF)\n}\n\n#清除连续相同的分型，比如顶分型-顶分型，底分型-底分型\nelimSameParting <- function(partingDF) {\n  firstIndex <- 1\n  first <- partingDF[firstIndex,]\n  secondIndex <- 2\n  second <- partingDF[secondIndex,]\n  print(partingDF[nrow(partingDF),1])\n  flog.debug(paste(\"check\",first$日期,\"and\",second$日期,\"with end date\",partingDF[nrow(partingDF),1]))\n  \n  while(!is.na(second$日期) && second$日期 <= partingDF[nrow(partingDF),1]) {\n    flog.debug(paste(\"check\",first$日期,\"and\",second$日期))\n    if (first$顶分型 == second$顶分型) {\n      if(first$顶分型) {\n        if(first$最高 > second$最高) {\n          flog.warn(paste(\"remove top parting\",second$日期))\n          partingDF[secondIndex,2:ncol(partingDF)] <- NA\n          secondIndex <- secondIndex + 1\n          second <- partingDF[secondIndex,]          \n        } else {\n          flog.warn(paste(\"remove top parting\",first$日期))\n          partingDF[firstIndex,2:ncol(partingDF)] <- NA\n          firstIndex <- secondIndex\n          first <- partingDF[firstIndex,]\n          secondIndex <- secondIndex + 1\n          second <- partingDF[secondIndex,] \n        }\n      }#end if(first$顶分型) \n      else { # it is 底分型\n        if(first$最低 < second$最低) {\n          flog.warn(paste(\"remove bottom parting\",second$日期))\n          partingDF[secondIndex,2:ncol(partingDF)] <- NA\n          secondIndex <- secondIndex + 1\n          second <- partingDF[secondIndex,]           \n        } else {\n          flog.warn(paste(\"remove bottom parting\",first$日期))\n          partingDF[firstIndex,2:ncol(partingDF)] <- NA\n          firstIndex <- secondIndex\n          first <- partingDF[firstIndex,]\n          secondIndex <- secondIndex + 1\n          second <- partingDF[secondIndex,] \n        }\n      }#end else { # it is 底分型      \n    }#end if (first$顶分型 == second$顶分型) \n    else {\n      firstIndex <- secondIndex\n      first <- partingDF[firstIndex,]\n      secondIndex <- secondIndex + 1\n      second <- partingDF[secondIndex,] \n    }\n  }#end while\n  partingDF <- na.omit(partingDF)\n  return(partingDF)\n}\n\n#消除不是笔的分型,\n#partingDF:通过elimSameParting消除了连续相同分型的分型数据\n#combinedData:通过processInclusion处理了包含关系的原始数据\n\ncaculatePartingLinePot <- function(partingDF,combinedData) {\n  lastLinePartingIndex <- 1\n  lastLineParting <- partingDF[lastLinePartingIndex,]\n  nextIndex <- 2\n  nextParting <- partingDF[nextIndex,]\n  #print(partingDF[nrow(partingDF),1])\n  flog.debug(paste(\"caculatePartingLinePot:check\",lastLineParting$日期,\"and\",nextParting$日期,\"with end date\",partingDF[nrow(partingDF),1]))\n  \n  emptyDF <- data.frame(\n    日期 = as.Date(character(\"0\")),\n    开盘 = numeric(0),\n    最高 = numeric(0),\n    最低 = numeric(0),\n    收盘 = numeric(0),\n    顶分型 = logical(),\n    成交量 = numeric(0),\n    成交额 = numeric(0))\n  \n  linePartingDF <- emptyDF\n  \n  linePartingDF <- rbind(linePartingDF,lastLineParting)\n  \n  \n  while(!is.na(nextParting$日期) && nextParting$日期 <= partingDF[nrow(partingDF),1]) {\n    flog.debug(paste(\"caculatePartingLinePot:check\",lastLineParting$日期,\"and\",nextParting$日期))\n    \n    lastLinePartingPlotInOrigData <- which(combinedData$日期 == lastLineParting$日期)\n    if(length(lastLinePartingPlotInOrigData) == 0) {\n      flog.error(paste(\"can not find lastLineParting date\",lastLineParting$日期))\n      return(NULL)\n    }\n    nextPlotInOrigData <- which(combinedData$日期 == nextParting$日期)\n    if(length(nextPlotInOrigData) == 0) {\n      flog.error(paste(\"can not find nextParting date\",nextParting$日期))\n      return(NULL)\n    }\n    \n    flog.debug(paste(\"lastLinePartingPlotInOrigData\",lastLinePartingPlotInOrigData,\"nextPlotInOrigData\",nextPlotInOrigData))\n    \n    if(abs(lastLinePartingPlotInOrigData - nextPlotInOrigData) > 3 && lastLineParting$顶分型!=nextParting$顶分型) {\n      if (lastLineParting$顶分型 && lastLineParting$最高 > nextParting$最高) {\n        linePartingDF <- rbind(linePartingDF,nextParting)\n        lastLinePartingIndex <- nextIndex\n        lastLineParting <- partingDF[lastLinePartingIndex,]\n      } else if (!lastLineParting$顶分型 && lastLineParting$最高 < nextParting$最高) {\n        linePartingDF <- rbind(linePartingDF,nextParting)\n        lastLinePartingIndex <- nextIndex\n        lastLineParting <- partingDF[lastLinePartingIndex,]\n      }\n      \n      nextIndex <- nextIndex+1\n      nextParting <- partingDF[nextIndex,]      \n    } else if (abs(lastLinePartingPlotInOrigData - nextPlotInOrigData) >3 && lastLineParting$顶分型==nextParting$顶分型) {\n      if (lastLineParting$顶分型 && lastLineParting$最高 < nextParting$最高) {\n        linePartingDF <- rbind(linePartingDF,nextParting)\n        lastLinePartingIndex <- nextIndex\n        lastLineParting <- partingDF[lastLinePartingIndex,]\n      } else if (!lastLineParting$顶分型 && lastLineParting$最低>nextParting$最低) {\n        linePartingDF <- rbind(linePartingDF,nextParting)\n        lastLinePartingIndex <- nextIndex\n        lastLineParting <- partingDF[lastLinePartingIndex,]\n      }      \n      \n      nextIndex <- nextIndex+1\n      nextParting <- partingDF[nextIndex,]  \n    } else if (abs(lastLinePartingPlotInOrigData - nextPlotInOrigData) <=3 && lastLineParting$顶分型!=nextParting$顶分型) {\n      nextIndex <- nextIndex+1\n      nextParting <- partingDF[nextIndex,]      \n    } else if (abs(lastLinePartingPlotInOrigData - nextPlotInOrigData) <=3 && lastLineParting$顶分型==nextParting$顶分型) {\n      if (lastLineParting$顶分型&&lastLineParting$最高<nextParting$最高) {\n        linePartingDF <- rbind(linePartingDF,nextParting)\n        \n        lastLinePartingIndex <- nextIndex\n        lastLineParting <- partingDF[lastLinePartingIndex,]\n        nextIndex <- nextIndex+1\n        nextParting <- partingDF[nextIndex,]        \n      } else if (!lastLineParting$顶分型&&lastLineParting$最低>nextParting$最低) {\n        linePartingDF <- rbind(linePartingDF,nextParting)\n        \n        lastLinePartingIndex <- nextIndex\n        lastLineParting <- partingDF[lastLinePartingIndex,]\n        nextIndex <- nextIndex+1\n        nextParting <- partingDF[nextIndex,]         \n      } else {\n        nextIndex <- nextIndex+1\n        nextParting <- partingDF[nextIndex,] \n      }\n    } else {\n      nextIndex <- nextIndex+1\n      nextParting <- partingDF[nextIndex,] \n    }\n  }\n  \n  return(linePartingDF)\n}\n\n\nremoveUnexpectedCandidate <- function(candidates,origData) {\n  for(i in 1:nrow(candidates)) {\n    candidate <- candidates[i,]\n    isTopParting <- candidate$顶分型\n    candDate <- candidate$日期\n    \n    \n    if(isTopParting) {\n      highDateInds <- which(origData$日期 == candDate)\n      leftHightDateInds <- highDateInds - 1\n      rightHightDateInds <- highDateInds + 1\n           \n      if (!(origData[leftHightDateInds,]$最低 < candidate$最低 \n          && origData[rightHightDateInds,]$最低 < candidate$最低)) {\n        candidates[i,2:ncol(candidate)] <- NA\n      }      \n    } else {\n      lowDateInds <- which(origData$日期 == candDate)\n      leftLowDateInds <- lowDateInds - 1\n      rightLowDateInds <- lowDateInds + 1\n      \n      if (!(origData[leftLowDateInds,]$最高 > candidate$最高 \n          && origData[rightLowDateInds,]$最高 > candidate$最高)) {\n        candidates[i,2:ncol(candidate)] <- NA\n      }      \n    }    \n  }\n  candidates <- na.omit(candidates)\n  return(candidates)\n}\n\n\ncaculateLine <- function(id,startDate,endDate) {  \n  path <- getwd()\n  fileName <- paste(path,\"//rxsj//\",id,\".txt\",sep=\"\")\n  flog.debug(paste(\"get file path\",fileName))\n  data <- readRXSJFile(fileName)\n  \n  firstCandidate <- findParting(data,startDate,endDate)\n  #parting <- elimSameParting(firstPDf)\n  combinedOrigData <- processInclusion(firstCandidate,data,startDate,endDate)\n  \n  secondPDF <- findParting(combinedOrigData,startDate,endDate)\n  secondPDF <- removeUnexpectedCandidate(secondPDF,combinedOrigData)\n  parting <- elimSameParting(secondPDF)\n  \n  lineParting <- caculatePartingLinePot(parting,combinedOrigData)\n  lineParting <- elimSameParting(lineParting)\n\n  return(lineParting)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1443540544015.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2475533892",
    "id" : "E8D3102B",
    "lastKnownWriteTime" : 1443801267,
    "path" : "C:/xtang/workspace/mystockanalysis/analysisRXSJ.R",
    "project_path" : "analysisRXSJ.R",
    "properties" : {
    },
    "source_on_save" : true,
    "type" : "r_source"
}