{
    "contents" : "setwd(\"C:\\\\xtang\\\\workspace\\\\mystockAnalysis\")\nlibrary(sqldf)\nlibrary(RCurl)\nlibrary(quantmod)\nlibrary(plyr)\nlibrary(logging)\nlibrary(futile.logger)\nlibrary(base)\nlibrary(plyr)\nflog.threshold(DEBUG) \n\n#file <- readRXSJFile(\"C:\\\\xtang\\\\workspace\\\\R\\\\stockAnalysis\\\\rxsj\\\\000001.txt\")\n#partingDataDF[order(as.Date(partingDataDF$日期,format=\"%d/%m/%Y\")),]\n\nSys.setenv(http_proxy=\"http://child-prc.intel.com:913\")\nhistoryTradeLink <- \"http://market.finance.sina.com.cn/downxls.php?date=2015-09-21&symbol=sz300205\"\n#download.file(historyTradeLink,destfile=\".\\\\test.xlsx\")\n\n#读取日线数据\nrxsj_col_names <- c(\"日期\",\"开盘\",\"最高\",\"最低\",\"收盘\",\"成交量\",\"成交额\")\nrxsj_colClasses <- c(\"Date\",\"numeric\",\"numeric\",\"numeric\",\"numeric\",\"numeric\",\"numeric\")\nreadRXSJFile <- function(filename) {\n  lines <- length(readLines(filename)) \n  #print(lines-3)\n  fileDF <- read.csv(filename,sep=\",\", header=FALSE,skip=2,nrows=(lines-3),col.names=rxsj_col_names,colClasses=rxsj_colClasses)\n  return(fileDF)\n}\n\ngetAllRXSJFiles <- function() {\n  wd <- getwd()\n  filePath <- paste(wd,\"//rxsj\",sep=\"\") \n  files <- list.files(filePath)\n  return(files)\n}\n\ncalculateTopParting <- function(origData,startDate,endDate) {\n  flog.debug(\"--------------------------------------------------------------------\")\n  flog.debug(paste(\"calculate date between\",startDate,\"and\",endDate))\n  \n  startDateInds <- shiftDateToRightIfNA(origData,startDate)\n  endDateInds <- shiftDateToLeftIfNA(origData,endDate)\n  startDate <- origData[startDateInds,]$日期\n  endDate <- origData[endDateInds,]$日期\n  \n  flog.debug(paste(\"after shift,calculate date between\",\n                   startDate,\"and\",endDate))\n  \n  partingDataDF <- data.frame(\n    日期 = as.Date(character(\"0\")),\n    开盘 = numeric(0),\n    最高 = numeric(0),\n    最低 = numeric(0),\n    收盘 = numeric(0),\n    成交量 = numeric(0),\n    成交额 = numeric(0)) \n  \n  sDate <- as.Date(startDate)\n  start <- -1\n  eDate <- as.Date(endDate)\n  end <- -1\n  \n  if ((sDate + 2) > eDate) {\n    flog.debug(paste(\"the start date\",startDate,\"is less than\",endDate,\"- 3 \"))\n    return(NULL)\n  }\n  \n  \n  len <- nrow(origData)\n  lastDate <- as.Date(origData[len,1])\n  flog.debug(paste(\"lastDate\",lastDate))\n  while(eDate > sDate) {\n    end <- which(origData$日期 == eDate)\n    if(length(end)!=0) {\n      if(eDate != as.Date(endDate)) {\n        flog.warn(paste(\"WARNING:shift end date from\",endDate,\"to\",eDate))  \n      }      \n      break\n    } \n    eDate <- eDate-1   \n  }\n  \n#   shiftDate2LeftIfNa(origData,eDate,sDate)\n#   flog.debug(paste(\"after shift to left the eDdate is\",eDate))\n  flog.debug(paste(\"1 sDate\",sDate,\"eDate\",eDate))\n  while(sDate < eDate) {\n    start <- which(origData$日期 == sDate)\n    if(length(start)!=0) {\n      if(sDate != as.Date(startDate)) {\n        flog.warn(paste(\"WARNING:shift start date from\",startDate,\"to\",sDate))\n      }      \n      break\n    } \n    sDate <- sDate + 1\n  }\n  flog.debug(paste(\"2 sDate\",sDate,\"eDate\",eDate))\n#   shiftDate2RightIfNa(origData,sDate,eDate)\n#   flog.debug(paste(\"after shift to right the sDdate is\",sDate))\n  \n  if(sDate == eDate) {\n    flog.debug(paste(\"can not find start date\",startDate))\n    return(NULL)\n  }\n  #subset according to duration\n  subData <- subset(origData,origData$日期>=sDate & origData$日期<= eDate,na.rm = TRUE)\n  flog.debug(paste(\"length subdata:\",nrow(subData)))\n  #get high price in the duration\n  highestPrice <- max(subData$最高,na.rm = TRUE)\n  flog.debug(paste(\"highestPrice:\",highestPrice))\n  #subset according to the high price\n  highestDataInds <- which(subData$最高==highestPrice)\n  print(subData[highestDataInds,])\n  highestData <- subData[highestDataInds,]\n\n  # if the highest price reaches most left or most right, it is not the parting\n  highDate <- as.Date(highestData[1,1])\n  flog.debug(paste(\"highDate:\",highDate))\n  flog.debug(paste(\"subData[1,1]:\",subData[1,1]))\n  flog.debug(paste(\"subData[,1]:\",subData[length(subData[,1]),1]))\n  if(highDate == subData[length(subData[,1]),1]) {\n    flog.info(paste(\"the highest price date reaches most right. most left:\",subData[1,1],\"highDate:\",highDate,\"most right:\",subData[length(subData[,1]),1]))\n    #pathToLeftFirstLowestPrice(subData,)\n    return(calculateTopParting(subData,sDate,highDate-1))\n  }\n   \n  if(highDate == subData[1,1]) {\n    flog.info(paste(\"the highest price date reaches most left. most left:\",subData[1,1],\"highDate:\",highDate,\"most right:\",subData[length(subData[,1]),1]))\n    #return(calculateTopParting(id,subData,sDate-1,highDate))\n    return(calculateTopParting(subData,highDate+1,eDate))\n  }\n\n  #check if the highest price date is already record\n  inds <- which(partingDataDF$日期==highDate)\n  if(length(inds) == 0) {\n    partingDataDF <- rbind(partingDataDF,highestData)\n    partingDataDF <- partingDataDF[order(as.Date(partingDataDF$日期,format=\"%d/%m/%Y\")),]\n    flog.debug(paste(\"partingDataDF$日期\",partingDataDF[1,1]))\n    flog.info(paste(\"insert highest date\",highDate)) \n  } else {\n    flog.error(paste(\"find the same high date\",highDate,\"between\",sDate,\"and\",eDate))\n    return(NULL)\n  }\n\n  newDf <- calculateTopParting(subData,sDate,highDate-1)\n  if (!is.null(newDf) && nrow(newDf) != 0) {\n    partingDataDF <- rbind(partingDataDF,newDf)\n    partingDataDF <- partingDataDF[order(as.Date(partingDataDF$日期,format=\"%d/%m/%Y\")),]    \n  }\n\n  newDf <- calculateTopParting(subData,highDate+1,eDate)\n  if(!is.null(newDf) && nrow(newDf) != 0) {\n    partingDataDF <- rbind(partingDataDF,newDf)\n    partingDataDF <- partingDataDF[order(as.Date(partingDataDF$日期,format=\"%d/%m/%Y\")),]      \n  }\n\n  return(partingDataDF)\n}\n\n\ncalculateBottomParting <- function(origData,startDate,endDate) {\n  flog.debug(\"--------------------------------------------------------------------\")\n  flog.debug(paste(\"calculate bottom parting date between\",startDate,\"and\",endDate))\n  \n  startDateInds <- shiftDateToRightIfNA(origData,startDate)\n  endDateInds <- shiftDateToLeftIfNA(origData,endDate)\n  startDate <- origData[startDateInds,]$日期\n  endDate <- origData[endDateInds,]$日期\n  \n  flog.debug(paste(\"after shift,calculate date between\",\n                   startDate,\"and\",endDate))  \n  \n  partingDataDF <- data.frame(\n    日期 = as.Date(character(\"0\")),\n    开盘 = numeric(0),\n    最高 = numeric(0),\n    最低 = numeric(0),\n    收盘 = numeric(0),\n    成交量 = numeric(0),\n    成交额 = numeric(0))  \n  \n  sDate <- as.Date(startDate)\n  start <- -1\n  eDate <- as.Date(endDate)\n  end <- -1\n  \n  if ((sDate + 2) > eDate) {\n    flog.debug(paste(\"the start date\",startDate,\"is less than\",endDate,\"- 3 \"))\n    return(NULL)\n  }\n  \n  \n  len <- nrow(origData)\n  lastDate <- as.Date(origData[len,1])\n  flog.debug(paste(\"lastDate\",lastDate))\n  while(eDate > sDate) {\n    end <- which(origData$日期 == eDate)\n    if(length(end)!=0) {\n      if(eDate != as.Date(endDate)) {\n        flog.warn(paste(\"WARNING:shift end date from\",endDate,\"to\",eDate))  \n      }      \n      break\n    } \n    eDate <- eDate-1   \n  }\n  \n  #   shiftDate2LeftIfNa(origData,eDate,sDate)\n  #   flog.debug(paste(\"after shift to left the eDdate is\",eDate))\n  flog.debug(paste(\"1 sDate\",sDate,\"eDate\",eDate))\n  while(sDate < eDate) {\n    start <- which(origData$日期 == sDate)\n    if(length(start)!=0) {\n      if(sDate != as.Date(startDate)) {\n        flog.warn(paste(\"WARNING:shift start date from\",startDate,\"to\",sDate))\n      }      \n      break\n    } \n    sDate <- sDate + 1\n  }\n  flog.debug(paste(\"2 sDate\",sDate,\"eDate\",eDate))\n  #   shiftDate2RightIfNa(origData,sDate,eDate)\n  #   flog.debug(paste(\"after shift to right the sDdate is\",sDate))\n  \n  if(sDate == eDate) {\n    flog.debug(paste(\"can not find start date\",startDate))\n    return(NULL)\n  }\n  #subset according to duration\n  subData <- subset(origData,origData$日期>=sDate & origData$日期<= eDate,na.rm = TRUE)\n  flog.debug(paste(\"length subdata:\",nrow(subData)))\n  #get low price in the duration\n  lowestPrice <- min(subData$最低,na.rm = TRUE)\n  #subset according to the low price\n  lowestData <- subset(subData,subData$最低==lowestPrice)\n  lowDate <- lowestData[1,1]\n  \n  # if the lowest price reaches most left or most right, it is not the parting\n  lowDate <- as.Date(lowestData[1,1])\n  flog.debug(paste(\"lowDate:\",lowDate))\n  flog.debug(paste(\"subData[1,1]:\",subData[1,1]))\n  flog.debug(paste(\"subData[,1]:\",subData[length(subData[,1]),1]))\n  if(lowDate == subData[length(subData[,1]),1]) {\n    flog.info(paste(\"the lowest price date reaches most right. most left:\",subData[1,1],\"lowDate:\",lowDate,\"most right:\",subData[length(subData[,1]),1]))\n    return(calculateBottomParting(subData,sDate,lowDate-1))\n  }\n  \n  if(lowDate == subData[1,1]) {\n    flog.info(paste(\"the lowest price date reaches most left. most left:\",subData[1,1],\"lowDate:\",lowDate,\"most right:\",subData[length(subData[,1]),1]))\n    return(calculateBottomParting(subData,lowDate+1,eDate))\n  }\n  \n  #check if the lowest price date is already record\n  inds <- which(partingDataDF$日期==lowDate)\n  if(length(inds) == 0) {\n    partingDataDF <- rbind(partingDataDF,lowestData)\n    partingDataDF <- partingDataDF[order(as.Date(partingDataDF$日期,format=\"%d/%m/%Y\")),]\n    flog.debug(paste(\"partingDataDF$日期\",partingDataDF$日期))\n    flog.info(paste(\"insert lowest date\",lowDate))    \n\n  } else {\n    flog.error(paste(\"find the same low date\",lowDate,\"between\",sDate,\"and\",eDate))\n    return(NULL)\n  }\n  \n  newDf <- calculateBottomParting(subData,sDate,lowDate-1)\n  print(\"-------------2 bottom newDf\")\n  print(newDf)\n  if(!is.null(newDf) && nrow(newDf) != 0) {\n    partingDataDF <- rbind(partingDataDF,newDf)\n    partingDataDF <- partingDataDF[order(as.Date(partingDataDF$日期,format=\"%d/%m/%Y\")),]        \n  }\n\n  newDf <- calculateBottomParting(subData,lowDate+1,eDate)\n  print(\"-------------2.1 bottom newDf\")\n  print(newDf)  \n  if (!is.null(newDf) && nrow(newDf) != 0) {\n    partingDataDF <- rbind(partingDataDF,newDf)\n    partingDataDF <- partingDataDF[order(as.Date(partingDataDF$日期,format=\"%d/%m/%Y\")),]    \n  }\n\n  return(partingDataDF)\n}\n\nvalidateBottomPartingType <- function(totalDataDF,bottom) {\n  botLeftDate <- bottom[1,1] - 1\n  oLeftDate <- botLeftDate \n\n  inds <- -1\n  while(botLeftDate > totalDataDF[1,1]) {\n    inds <- which(totalDataDF$日期 == botLeftDate)\n    if(length(inds)!=0) {\n      if(botLeftDate != as.Date(oLeftDate)) {\n        flog.warn(paste(\"WARNING:shift left date from\",oLeftDate,\"to\",botLeftDate))  \n      }      \n      break\n    } \n    botLeftDate <- botLeftDate-1   \n  }  \n  \n  if(length(inds) == 0) {\n    flog.warn(paste(\"the bottom left date\",botLeftDate,\"is not found in total data\"))\n    return(FALSE)\n  }\n  botLeftLowPrice <- totalDataDF$最低[inds]\n  \n  botRightDate <- bottom[1,1] + 1\n  oRightDate <- botRightDate\n  \n  inds <- -1\n  while(botRightDate < totalDataDF[nrow(totalDataDF),1]) {\n    inds <- which(totalDataDF$日期 == botRightDate)\n    if(length(inds)!=0) {\n      if(botRightDate != as.Date(oRightDate)) {\n        flog.warn(paste(\"WARNING:shift left date from\",oRightDate,\"to\",botRightDate))  \n      }      \n      break\n    } \n    botRightDate <- botRightDate+1   \n  }   \n  \n  if(length(inds) == 0) {\n    flog.warn(paste(\"the bottom right date\",botRightDate,\"is not found in total data\"))\n    return(FALSE)\n  }     \n  botRightLowPrice <- totalDataDF$最低[inds]\n  \n  bottomLowPrice <- bottom$最低[1]\n  flog.debug(paste(\"check botLeftLowPrice\",botLeftLowPrice,\"bottomLowPrice\",bottomLowPrice,\"botRightDate\",botRightDate))\n  \n  if(min(botLeftLowPrice,bottomLowPrice,botRightLowPrice) != bottomLowPrice) {\n    flog.error(paste(\"the bottomLowDate\",bottom[1,1],\"is not the bottom parting, check failed!\"))\n    return(FALSE)\n  }\n  return(TRUE)\n}\n\nvalidateLowPriceBetweenTwoBtm <- function(totalDataDF,leftBot,rightBot) {\n  leftBotDate <- leftBot[1,1]\n  inds <- which(totalDataDF$日期 == leftBotDate)\n  if(length(inds) == 0) {\n    flog.warn(paste(\"the leftBotDate date\",leftBotDate,\"is not found in total data\"))\n    return(FALSE)\n  }\n  \n  rightBotDate <- rightBot[1,1]\n  inds <- which(totalDataDF$日期 == rightBotDate)\n  if(length(inds) == 0) {\n    flog.warn(paste(\"the rightBotDate date\",rightBot,\"is not found in total data\"))\n    return(FALSE)\n  }\n  \n  df <- calculateBottomParting(totalDataDF,leftBotDate,rightBotDate)\n  if(!is.null(df)) {\n    flog.error(paste(\"there is another bottom parting\",df[1,1],\"between\",leftBotDate,\"and\",rightBotDate,\", check failed!\"))\n    return(FALSE)\n  }\n  return(TRUE)\n}\n\nvalidateBottomParting <- function(totalDataDF,bottomPartingDF) {\n  for(i in 1:nrow(bottomPartingDF)) {\n    bot1 <- bottomPartingDF[i,]\n    bot1Date <- bot1[1,1]\n    flog.debug(paste(\"check bottom parting\",bot1Date))\n    inds <- which(totalDataDF$日期 == bot1Date)\n    if(length(inds) == 0) {\n      flog.warn(paste(\"the bottom parting\",bot1Date,\"is not found in total data\"))\n      return(FALSE)\n    }\n    \n    \n    i <- i + 1\n    if(i >nrow(bottomPartingDF)) {\n      break\n    }\n    \n    \n    bot2 <- bottomPartingDF[i,]\n    bot2Date <- bot2[1,1]\n    flog.debug(paste(\"check bottom parting\",bot2Date))\n    inds <- which(totalDataDF$日期 == bot2Date)\n    if(length(inds) == 0) {\n      flog.warn(paste(\"the bottom parting\",bot2Date,\"is not found in total data\"))\n      return(FALSE)\n    }\n    \n    if(!(validateBottomPartingType(totalDataDF,bot1)\n         && validateLowPriceBetweenTwoBtm(totalDataDF,bot1,bot2))) {\n      flog.error(paste(\"check bottom parting\",bot1Date,\"failed\"))\n      return(FALSE)\n    }\n  }\n  return(TRUE)\n}\n\nfindParting <- function(df,startDate=NULL,endDate=NULL) {\n  if(is.null(startDate)) {\n    startDate <- df[1,]$日期\n  }\n  \n  if(is.null(endDate)) {\n    endDate <- df[nrow(df),]$日期\n  }\n  \n  topParting <- calculateTopParting(df,startDate,endDate)\n#   print(\"---------- top parting--------------\")\n#   print(topParting)\n  if (!is.null(topParting)) {\n    topParting <- addOneColToDF(topParting,\"收盘\",c(TRUE),\"顶分型\")  \n  }\n\n  bottomParting <- calculateBottomParting(df,startDate,endDate)\n  if(!is.null(bottomParting)) {\n    bottomParting <- addOneColToDF(bottomParting,\"收盘\",c(FALSE),\"顶分型\")  \n  }\n  \n#   print(\"----------bottomParting -------------\")\n#   print(bottomParting)\n#   \n#   print(\"--------------df-----------------------\")\n#   print(df)\n  \n  partingDataDF <- rbind(topParting,bottomParting)\n#   print(\"----------partingDataDF -------------\")\n#   print(partingDataDF)  \n  if(!is.null(partingDataDF)) {\n    partingDataDF <- partingDataDF[order(as.Date(partingDataDF$日期,format=\"%d/%m/%Y\")),]  \n  }\n  \n  return(partingDataDF)\n}\n\nshiftDateToLeftIfNA <- function(df,date) {\n  inds <- -1 \n  oDate <- date\n  while(date >= df[1,1]) {\n    inds <- which(df$日期 == date)\n    if(length(inds)!=0) {\n      if(date != as.Date(oDate)) {\n        flog.warn(paste(\"WARNING:shift date to left from\",oDate,\"to\",date))  \n      }      \n      return(inds)\n    } \n    date <- date-1  \n  }\n  return(inds)\n}\n\nshiftDateToRightIfNA <- function(df,date) {\n  inds <- -1 \n  oDate <- date\n  while(date <= df[nrow(df),1]) {\n    inds <- which(df$日期 == date)\n    if(length(inds)!=0) {\n      if(date != as.Date(oDate)) {\n        flog.warn(paste(\"WARNING:shift date to right from\",oDate,\"to\",date))  \n      }      \n      return(inds)\n    } \n    date <- date+1  \n  }\n  return(inds)\n}\n\n\n#根据分型数据处理包含关系\nprocessInclusion <- function(partingDataDF=data.frame(),origDataDF=data.frame(),startDate=NULL,endDate=NULL) {\n  if(is.null(startDate)) {\n    startDate <- origDataDF[1,1]\n  } \n  \n  if (is.null(endDate)) {\n    endDate <- origDataDF[nrow(origDataDF),1]\n  }\n  \n  flog.debug(paste(\"check date between\",startDate,\"and\",endDate))  \n  \n  startInds <- which(origDataDF$日期 == startDate)\n  if(length(startInds) == 0) {\n    flog.error(paste(\"can not find sart date\",startDate))\n    return(NULL)\n  }\n\n  endInds <- which(origDataDF$日期 == endDate)\n  if(length(endInds) == 0) {\n    flog.error(paste(\"can not find end date\",endDate))\n    return(NULL)\n  }\n  \n  emptyDF <- data.frame(\n    日期 = as.Date(character(\"0\")),\n    开盘 = numeric(0),\n    最高 = numeric(0),\n    最低 = numeric(0),\n    收盘 = numeric(0),\n    顶分型 = logical(),\n    成交量 = numeric(0),\n    成交额 = numeric(0))\n  \n  \n  \n  #regionData <- subset(origDataDF,origDataDF$日期 >= startDate && origDataDF$日期 <= endDate)\n  \n  for(i in 1:nrow(partingDataDF)) {\n    candiInds <- c()\n    combinedDataDF <- emptyDF\n    date <- partingDataDF[i,1]\n    highestPrice <- partingDataDF[i,3]\n    lowestPrice <- partingDataDF[i,4]\n    isTopParting <- partingDataDF[i,6]\n    \n    flog.debug(paste(\"check\",date,\"by\",highestPrice,\"and\",lowestPrice,\"with isTopParting\",isTopParting))\n    \n    inds <- which(origDataDF$日期 == date)\n    if (length(inds) == 0) {\n      flog.error(paste(\"can not find date\",date))\n      return(NULL)\n    }\n    \n    if (length(inds) > 1) {\n      flog.error(paste(\"find more than one date\",inds))\n      return(NULL)      \n    }\n    \n    flog.debug(paste(\"inds\",inds,\"startInds\",startInds,\"endInds\",endInds))\n    #subData <- subset(origDataDF, origDataDF$最低 >= lowestPrice & origDataDF$最高 <= highestPrice)\n    subData <- subset(origDataDF, (origDataDF$最低 >= lowestPrice & origDataDF$最高 <= highestPrice) | \n                        (origDataDF$收盘 >= 2293 & origDataDF$开盘 <= 2347) | (origDataDF$开盘 >= 2293 & origDataDF$收盘 <= 2347))\n\n    #     subDataPlots <- which(origDataDF$日期 == subData$日期)\n    #     flog.debug(paste(\"subDataPlots:\",subDataPlots))\n    \n    #print(subData)\n\n    if (nrow(subData) > 1) {\n      j <- 1\n      subDataPlots <- c()\n      while(j < nrow(subData)) {\n        sbdp <- which(origDataDF$日期 == subData[j,]$日期)\n        if(length(sbdp) == 0) {\n          flog.error(paste(\"can not find\",subData[j,]$日期))\n          return(NULL)\n        }\n        flog.debug(paste(\"sbdp\",sbdp,\"date\",origDataDF[sbdp,1],\"highprice\",origDataDF[sbdp,3],\"lowprice\",origDataDF[sbdp,4]))\n        subDataPlots <- c(subDataPlots,sbdp)\n        j<-j+1\n      }\n      #flog.debug(paste(\"subDataPlots:\",subDataPlots))\n      #print(subDataPlots)\n      \n      if(length(subDataPlots) > 1) {\n        partingPlot <- which(subData$日期 == date)\n        flog.debug(paste(\"partingPlot\",partingPlot,\"for date\",date))\n        \n        testPlot <- inds - 1\n        while(testPlot %in% subDataPlots) {\n          flog.debug(paste(\"add left candidate plot\",testPlot))\n          candiInds <- c(candiInds,testPlot)\n          combinedDataDF <- rbind(combinedDataDF,origDataDF[testPlot,])\n          testPlot <- testPlot - 1\n        }\n        \n        testPlot <- inds + 1\n        while(testPlot %in% subDataPlots) {\n          flog.debug(paste(\"add right candidate plot\",testPlot))\n          candiInds <- c(candiInds,testPlot)\n          combinedDataDF <- rbind(combinedDataDF,origDataDF[testPlot,])\n          testPlot <- testPlot + 1\n        }\n                \n        flog.debug(paste(\"candidate inds:\",candiInds,\"for\",inds))\n        if(length(candiInds) > 0) {\n          combinedDataDF <- combinedDataDF[order(as.Date(combinedDataDF$日期,format=\"%d/%m/%Y\")),]\n          print(combinedDataDF)\n          if(isTopParting) {\n            highestLowPrice <- max(combinedDataDF[,4])\n            flog.warn(paste(\"set the date\",origDataDF[inds,1],\" original low price\",origDataDF[inds,4],\"to\",highestLowPrice))\n            origDataDF[inds,4] <- highestLowPrice\n          } else {\n            lowestHighPrice <- min(combinedDataDF[,3])\n            flog.warn(paste(\"set the date\",origDataDF[inds,1],\" original high price\",origDataDF[inds,3],\"to\",lowestHighPrice))\n            origDataDF[inds,3] <- lowestHighPrice            \n          }\n          \n          for(i in 1:length(candiInds)) {            \n            flog.warn(paste(\"set the date\",as.Date(origDataDF[candiInds[i],1]),\"value to NA\"))\n            origDataDF[candiInds[i],2:ncol(origDataDF)] <- NA\n            flog.debug(origDataDF[candiInds[i],])\n          }# end for\n        }#end if\n      }#end if      \n    }#end if\n    \n    i <- i + 1\n  }\n  origDataDF <- na.omit(origDataDF)\n  return(origDataDF)\n}\n\n#清除连续相同的分型，比如顶分型-顶分型，底分型-底分型\nelimSameParting <- function(partingDF) {\n  firstIndex <- 1\n  first <- partingDF[firstIndex,]\n  secondIndex <- 2\n  second <- partingDF[secondIndex,]\n  print(partingDF[nrow(partingDF),1])\n  flog.debug(paste(\"check\",first$日期,\"and\",second$日期,\"with end date\",partingDF[nrow(partingDF),1]))\n  \n  while(!is.na(second$日期) && second$日期 <= partingDF[nrow(partingDF),1]) {\n    flog.debug(paste(\"check\",first$日期,\"and\",second$日期))\n    if (first$顶分型 == second$顶分型) {\n      if(first$顶分型) {\n        if(first$最高 > second$最高) {\n          flog.warn(paste(\"remove top parting\",second$日期))\n          partingDF[secondIndex,2:ncol(partingDF)] <- NA\n          secondIndex <- secondIndex + 1\n          second <- partingDF[secondIndex,]          \n        } else {\n          flog.warn(paste(\"remove top parting\",first$日期))\n          partingDF[firstIndex,2:ncol(partingDF)] <- NA\n          firstIndex <- secondIndex\n          first <- partingDF[firstIndex,]\n          secondIndex <- secondIndex + 1\n          second <- partingDF[secondIndex,] \n        }\n      }#end if(first$顶分型) \n      else { # it is 底分型\n        if(first$最低 < second$最低) {\n          flog.warn(paste(\"remove bottom parting\",second$日期))\n          partingDF[secondIndex,2:ncol(partingDF)] <- NA\n          secondIndex <- secondIndex + 1\n          second <- partingDF[secondIndex,]           \n        } else {\n          flog.warn(paste(\"remove bottom parting\",first$日期))\n          partingDF[firstIndex,2:ncol(partingDF)] <- NA\n          firstIndex <- secondIndex\n          first <- partingDF[firstIndex,]\n          secondIndex <- secondIndex + 1\n          second <- partingDF[secondIndex,] \n        }\n      }#end else { # it is 底分型      \n    }#end if (first$顶分型 == second$顶分型) \n    else {\n      firstIndex <- secondIndex\n      first <- partingDF[firstIndex,]\n      secondIndex <- secondIndex + 1\n      second <- partingDF[secondIndex,] \n    }\n  }#end while\n  partingDF <- na.omit(partingDF)\n  return(partingDF)\n}\n\n#消除不是笔的分型,\n#partingDF:通过elimSameParting消除了连续相同分型的分型数据\n#combinedData:通过processInclusion处理了包含关系的原始数据\n\ncaculatePartingLinePot <- function(partingDF,combinedData) {\n  lastLinePartingIndex <- 1\n  lastLineParting <- partingDF[lastLinePartingIndex,]\n  nextIndex <- 2\n  nextParting <- partingDF[nextIndex,]\n  #print(partingDF[nrow(partingDF),1])\n  flog.debug(paste(\"caculatePartingLinePot:check\",lastLineParting$日期,\"and\",nextParting$日期,\"with end date\",partingDF[nrow(partingDF),1]))\n  \n  emptyDF <- data.frame(\n    日期 = as.Date(character(\"0\")),\n    开盘 = numeric(0),\n    最高 = numeric(0),\n    最低 = numeric(0),\n    收盘 = numeric(0),\n    顶分型 = logical(),\n    成交量 = numeric(0),\n    成交额 = numeric(0))\n  \n  linePartingDF <- emptyDF\n  \n  linePartingDF <- rbind(linePartingDF,lastLineParting)\n  \n  \n  while(!is.na(nextParting$日期) && nextParting$日期 <= partingDF[nrow(partingDF),1]) {\n    flog.debug(paste(\"caculatePartingLinePot:check\",lastLineParting$日期,\"and\",nextParting$日期))\n    \n    lastLinePartingPlotInOrigData <- which(combinedData$日期 == lastLineParting$日期)\n    if(length(lastLinePartingPlotInOrigData) == 0) {\n      flog.error(paste(\"can not find lastLineParting date\",lastLineParting$日期))\n      return(NULL)\n    }\n    nextPlotInOrigData <- which(combinedData$日期 == nextParting$日期)\n    if(length(nextPlotInOrigData) == 0) {\n      flog.error(paste(\"can not find nextParting date\",nextParting$日期))\n      return(NULL)\n    }\n    \n    flog.debug(paste(\"lastLinePartingPlotInOrigData\",lastLinePartingPlotInOrigData,\"nextPlotInOrigData\",nextPlotInOrigData))\n    \n    if(abs(lastLinePartingPlotInOrigData - nextPlotInOrigData) > 3 && lastLineParting$顶分型!=nextParting$顶分型) {\n      if (lastLineParting$顶分型 && lastLineParting$最高 > nextParting$最高) {\n        linePartingDF <- rbind(linePartingDF,nextParting)\n        lastLinePartingIndex <- nextIndex\n        lastLineParting <- partingDF[lastLinePartingIndex,]\n      } else if (!lastLineParting$顶分型 && lastLineParting$最高 < nextParting$最高) {\n        linePartingDF <- rbind(linePartingDF,nextParting)\n        lastLinePartingIndex <- nextIndex\n        lastLineParting <- partingDF[lastLinePartingIndex,]\n      }\n      \n      nextIndex <- nextIndex+1\n      nextParting <- partingDF[nextIndex,]      \n    } else if (abs(lastLinePartingPlotInOrigData - nextPlotInOrigData) >3 && lastLineParting$顶分型==nextParting$顶分型) {\n      if (lastLineParting$顶分型 && lastLineParting$最高 < nextParting$最高) {\n        linePartingDF <- rbind(linePartingDF,nextParting)\n        lastLinePartingIndex <- nextIndex\n        lastLineParting <- partingDF[lastLinePartingIndex,]\n      } else if (!lastLineParting$顶分型 && lastLineParting$最低>nextParting$最低) {\n        linePartingDF <- rbind(linePartingDF,nextParting)\n        lastLinePartingIndex <- nextIndex\n        lastLineParting <- partingDF[lastLinePartingIndex,]\n      }      \n      \n      nextIndex <- nextIndex+1\n      nextParting <- partingDF[nextIndex,]  \n    } else if (abs(lastLinePartingPlotInOrigData - nextPlotInOrigData) <=3 && lastLineParting$顶分型!=nextParting$顶分型) {\n      nextIndex <- nextIndex+1\n      nextParting <- partingDF[nextIndex,]      \n    } else if (abs(lastLinePartingPlotInOrigData - nextPlotInOrigData) <=3 && lastLineParting$顶分型==nextParting$顶分型) {\n      if (lastLineParting$顶分型&&lastLineParting$最高<nextParting$最高) {\n        linePartingDF <- rbind(linePartingDF,nextParting)\n        \n        lastLinePartingIndex <- nextIndex\n        lastLineParting <- partingDF[lastLinePartingIndex,]\n        nextIndex <- nextIndex+1\n        nextParting <- partingDF[nextIndex,]        \n      } else if (!lastLineParting$顶分型&&lastLineParting$最低>nextParting$最低) {\n        linePartingDF <- rbind(linePartingDF,nextParting)\n        \n        lastLinePartingIndex <- nextIndex\n        lastLineParting <- partingDF[lastLinePartingIndex,]\n        nextIndex <- nextIndex+1\n        nextParting <- partingDF[nextIndex,]         \n      } else {\n        nextIndex <- nextIndex+1\n        nextParting <- partingDF[nextIndex,] \n      }\n    } else {\n      nextIndex <- nextIndex+1\n      nextParting <- partingDF[nextIndex,] \n    }\n  }\n  \n  return(linePartingDF)\n}\n\n\nremoveUnexpectedCandidate <- function(candidates,origData) {\n  if(nrow(candidates) == 1) {\n    return(na.omit(candidates))\n  }\n  \n  for(i in 1:nrow(candidates)) {\n    candidate <- candidates[i,]\n    isTopParting <- candidate$顶分型\n    candDate <- candidate$日期\n    \n    \n    if(isTopParting) {\n      highDateInds <- which(origData$日期 == candDate)\n      leftHightDateInds <- highDateInds - 1\n      rightHightDateInds <- highDateInds + 1\n           \n      if (!(origData[leftHightDateInds,]$最低 < candidate$最低 \n          && origData[rightHightDateInds,]$最低 < candidate$最低)) {\n        candidates[i,2:ncol(candidate)] <- NA\n      }      \n    } else {\n      lowDateInds <- which(origData$日期 == candDate)\n      leftLowDateInds <- lowDateInds - 1\n      rightLowDateInds <- lowDateInds + 1\n      \n      if (!(origData[leftLowDateInds,]$最高 > candidate$最高 \n          && origData[rightLowDateInds,]$最高 > candidate$最高)) {\n        candidates[i,2:ncol(candidate)] <- NA\n      }      \n    }    \n  }\n  candidates <- na.omit(candidates)\n  return(candidates)\n}\n\n\ncaculateLineStructure <- function(id,startDate=NULL,endDate=NULL) {  \n  path <- getwd()\n  fileName <- paste(path,\"//rxsj//\",id,\".txt\",sep=\"\")\n  flog.debug(paste(\"get file path\",fileName))\n  data <- readRXSJFile(fileName)\n  \n  if(is.null(startDate)) {\n    startDate <- data[1,]$日期\n  }\n  \n  if(is.null(endDate)) {\n    end <- data[nrow(data),]$日期\n  }\n  \n  startDateIndex <- which(data$日期==startDate)\n  startData <- data[startDateIndex,]\n  \n  firstCandidate <- findParting(data,startDate,endDate)\n  if(is.null(firstCandidate)) {\n    flog.warn(paste(\"the firstCandidate is null,maybe there is no parting from\",startDate,\"to\",endDate,\"please check the following data\"))\n    print(data)\n    return(NULL)\n  }\n  #parting <- elimSameParting(firstPDf)\n  #combinedOrigData <- processInclusion(firstCandidate,data,startDate,endDate)\n  combinedOrigData <- concludeInclusion(data)\n  \n  secondPDF <- findParting(combinedOrigData,startDate,endDate)\n  if(is.null(secondPDF)) {\n    flog.warn(paste(\"the secondPDF is null,maybe after combined, there is no parting from\",startDate,\"to\",endDate,\"please check the following combined data\"))\n    print(combinedOrigData)\n    return(NULL)\n  }\n  secondPDF <- removeUnexpectedCandidate(secondPDF,combinedOrigData)\n  parting <- elimSameParting(secondPDF)\n  \n  lineParting <- caculatePartingLinePot(parting,combinedOrigData)\n  linePot <- elimSameParting(lineParting)\n  \n  lineStruct <- transformLinePot2LineStructure(linePot,startData)\n  \n  return(lineStruct)\n}\n\n\n#将分笔的点结构转换成笔的表示形势\ntransformLinePot2LineStructure <- function(caculatedLinePot,startRow) {\n  lineStructure <- data.frame(\n    日期 = as.Date(character(\"0\")),\n    最高 = numeric(0),\n    最低 = numeric(0),\n    向上 = logical())\n\n  j <- 1\n  for(i in 2:nrow(caculatedLinePot)) {\n    first <- caculatedLinePot[i-1,]\n    second <- caculatedLinePot[i,]\n    date <- first$日期\n    \n    if(first$顶分型 && !second$顶分型) {\n      if(j == 1) {\n        lineStructure <- rbind(lineStructure,data.frame(\n          日期=startRow$日期,最高=startRow$最高,最低=startRow$最低,向上=TRUE))        \n      }\n      lineStructure <- rbind(lineStructure,data.frame(\n        日期=date,最高=first$最高,最低=second$最低,向上=FALSE))\n    } else if (!first$顶分型 && second$顶分型) {\n      if(j == 1) {\n        lineStructure <- rbind(lineStructure,data.frame(\n          日期=startRow$日期,最高=startRow$最高,最低=startRow$最低,向上=FALSE))        \n      }      \n      lineStructure <- rbind(lineStructure,data.frame(\n        日期=date,最高=second$最高,最低=first$最低,向上=TRUE))\n    } else {\n      flog.error(paste(\"the line pot is error\"))\n      return(NULL)\n    }\n    j <- j + 1\n    i <- i + 1\n  }\n  return(lineStructure)\n}\n\n\n\n#将笔的结构“伪装”成交易数据\nfakeLineStruce2Kline <- function(lineStructure) {\n  lineStructure <- addOneColToDF(lineStructure,\"日期\",0,\"开盘\")\n  lineStructure <- addOneColToDF(lineStructure,\"最低\",0,\"收盘\")\n  lineStructure <- addOneColToDF(lineStructure,\"收盘\",0,\"成交量\")\n  lineStructure <- addOneColToDF(lineStructure,\"收盘\",0,\"成交额\")\n  \n  applyFun <- function(x) {\n    print(x$日期)\n    if(x$向上) {\n      x$开盘 <- x$最低\n      x$收盘 <- x$最高\n    } else {\n      x$开盘 <- x$最高\n      x$收盘 <- x$最低\n    }\n    print(x)\n  }\n  \n  lineStructure <- adply(lineStructure,1, applyFun)\n  lineStructure <- lineStructure[,-which(names(lineStructure)==\"向上\")]\n  return(lineStructure)\n}\n\nconcludeUpCharactSequence <- function(lineStructure) {\n  return(adply(lineStruct,1, function(x) if(x$向上) return(x)))\n}\n\nconcludeDownCharactSequence <- function(lineStructure) {\n  return(adply(lineStruct,1, function(x) if(!x$向上) return(x)))\n}\n\n#lineStruct <- caculateLineStructure(\"000001\",\"2013-06-25\",\"2015-09-22\")\nconcludeSegment <- function(lineStruct) {\n  \n  segment <- data.frame(\n    日期 = as.Date(character(\"0\")),\n    开盘 = numeric(0),\n    最高 = numeric(0),\n    最低 = numeric(0),\n    收盘 = numeric(0),\n    顶分型 = logical(),\n    isUpSeq = logical(),\n    成交额 = numeric(0),\n    成交量 = numeric(0))\n  \n  #segment <- rbind(segment,lineStruct[1,])\n  \n  upSeq <- concludeUpCharactSequence(lineStruct)\n  starndarUpSeq <- concludeInclusion(upSeq)\n  print(\"####starndarUpSeq:\")\n  print(starndarUpSeq)  \n  fakeUpKLine <- fakeLineStruce2Kline(starndarUpSeq)\n  upSeqParting <- findParting(fakeUpKLine)\n    \n  downSeq <- concludeDownCharactSequence(lineStruct)\n  starndarDownSeq <- concludeInclusion(downSeq)\n  print(\"####starndarDownSeq:\")\n  print(starndarDownSeq)    \n  fakeDownKLine <- fakeLineStruce2Kline(starndarDownSeq)\n  downSeqParting <- findParting(fakeDownKLine)\n  \n#   stardSeq <- rbind(starndarUpSeq,starndarDownSeq)\n#   stardSeq <- stardSeq[order(as.Date(stardSeq$日期,format=\"%d/%m/%Y\")),]  \n#   fakeStardSeqKLine <- fakeLineStruce2Kline(stardSeq)\n#   drawKline(fakeStardSeqKLine)  \n  \n  print(\"####upSeqParting:\")\n  print(upSeqParting)\n  print(\"####downSeqParting:\")\n  print(downSeqParting)\n  \n\n  \n  upSeqParting<-addOneColToDF(upSeqParting,\"顶分型\",TRUE,\"isUpSeq\")\n  downSeqParting<-addOneColToDF(downSeqParting,\"顶分型\",FALSE,\"isUpSeq\")\n\n  seqParting <- rbind(upSeqParting,downSeqParting)\n  seqParting <- seqParting[order(as.Date(seqParting$日期,format=\"%d/%m/%Y\")),]\n  print(seqParting)\n\n  validateParting <- function(parting,inds) {    \n    if(length(inds) == 0) {\n      flog.error(paste(\"can not find\",parting[i,]$日期,\"in starndarUpSeq\"))\n      return(NULL)\n    }\n    \n    left <- parting[inds-1,]\n    mid <- parting[inds,]\n    right <- parting[inds+1,]\n    \n    if(is.null(left) || is.na(left) || nrow(left) == 0) {\n      flog.error(paste(\"parting\",parting[inds,]$日期,\"left data is empty\"))\n      return(FALSE)\n    }\n    \n    if(is.null(right) || is.na(right) || nrow(right) == 0) {\n      flog.error(paste(\"parting\",parting[inds,]$日期,\"right data is empty\"))\n      return(FALSE)\n    }\n    \n    return(TRUE)\n  }\n\n  i <- 1\n  #isUp <- lineStruct[i,]$向上\n  while(i <= nrow(seqParting)) {\n    if(seqParting[i,]$isUpSeq & seqParting[i,]$顶分型 ) { \n      #是向上开始的一笔的特征序列，并且是顶分型\n      inds <- which(starndarUpSeq$日期 == seqParting[i,]$日期)      \n      if(!validateParting(starndarUpSeq,inds)) {\n        return(NULL)\n      }\n      \n      left <- starndarUpSeq[inds-1,]\n      mid <- starndarUpSeq[inds,]\n      right <- starndarUpSeq[inds+1,]\n      \n      if(left$最高 >= mid$最低) {\n        #有重合区域\n        segment <- rbind(segment,seqParting[i,])\n        flog.info(paste(\"find up segment at date\",seqParting[i,]$日期))\n        i <- i + 1\n      } else {\n        #有跳空缺口\n        j <- i + 1\n        while(j <= nrow(seqParting)) {\n          if (seqParting[j,]$isUpSeq & seqParting[j,]$顶分型) {\n            #有一个新的向上序列顶分型,以该顶分型为起点，重新找向下特征序列的底分型\n            break            \n          } else if(!seqParting[j,]$isUpSeq & !seqParting[j,]$顶分型) {\n            #找到向下特征序列的底分型\n            segment <- rbind(segment,seqParting[i,])\n            flog.info(paste(\"find up segment at date\",seqParting[i,]$日期))\n            break            \n          }\n          j <- j + 1\n        }\n        i <- j\n      }\n    } #end if (seqParting[i,]$isUpSeq & seqParting[i,]$顶分型 )  \n    else if (!seqParting[i,]$isUpSeq & !seqParting[i,]$顶分型 ) {\n      inds <- which(starndarDownSeq$日期 == seqParting[i,]$日期)      \n      if(!validateParting(starndarDownSeq,inds)) {\n        return(NULL)\n      }\n      \n      left <- starndarDownSeq[inds-1,]\n      mid <- starndarDownSeq[inds,]\n      right <- starndarDownSeq[inds+1,]\n      \n      if(left$最低 <= mid$最高) {\n        #有重合区域\n        segment <- rbind(segment,seqParting[i,])\n        flog.info(paste(\"find down segment at date\",seqParting[i,]$日期))\n        i <- i + 1\n      } else {\n        #有跳空缺口\n        j <- i + 1\n        while(j <= nrow(seqParting)) {\n          if (!seqParting[j,]$isUpSeq & !seqParting[j,]$顶分型 ) {\n            #有一个新的向下序列底分型,以该顶分型为起点，重新找向上特征序列的顶分型\n            break            \n          } else if(seqParting[j,]$isUpSeq & seqParting[j,]$顶分型) {\n            #找到向上特征序列的顶分型\n            segment <- rbind(segment,seqParting[i,])\n            flog.info(paste(\"find down segment at date\",seqParting[i,]$日期))\n            break            \n          }\n          j <- j + 1\n        }\n        i <- j\n      }\n    } # end !seqParting[i,]$isUpSeq & !seqParting[i,]$顶分型 \n    i <- i + 1\n  }\n  return(segment)\n}\n\n\nconcludeInclusion <- function(data) {\n  flog.debug(data)\n  if(is.null(data) || nrow(data) == 0) {\n    flog.info(\"data is null or empty\")\n    return(NULL)\n  }\n  \n  flog.debug(paste(\"nrow data\",nrow(data)))\n  \n  if(nrow(data) <= 2) {\n    return(data)\n  }\n  \n  i <- 1\n  j <- i + 1\n  \n  while(j <= nrow(data)) { #skip all the first inclusion relationship, i always point to the high length Kline\n    first <- data[i,]\n    second <- data[j,]\n    if(first$最高>=second$最高 & first$最低 <= second$最低) {\n      data[j,2:ncol(data)] <- NA\n      j <- j + 1\n    } else if (first$最高<second$最高 & first$最低 > second$最低) {\n      data[i,2:ncol(data)] <- NA\n      i <- j\n      j <- j + 1\n    } else {\n      break\n    }\n  }\n  \n  flog.debug(paste(\"after skip all the first inclusion relationship\",\"i\",i,\"j\",j))\n  \n  if(j > nrow(data)) {\n    flog.warn(paste(\"all the data between\",data[1,]$日期,\"and\",data[nrow(data),]$日期,\"is the inclusion relationship\"))\n    return(NULL)\n  }\n  \n  p <- i\n  i <- j\n  j <- j + 1\n  while(j <= nrow(data)) {\n    left <- data[p,]\n    mid <- data[i,]\n    right <- data[j,]\n    \n    if((left$最高>=mid$最高 & left$最低 <= mid$最低) || (left$最高<mid$最高 & left$最低 > mid$最低)) {\n      flog.error(\"the left one\",left$日期,\"should not have inclusion relationship with mid\",mid$日期)\n      return(NULL)\n    }\n    \n    if(left$最低 >= mid$最低) {\n      # like                 |          |   |\n      #  |         |         | |        | | |\n      #  | | | or  | | | or    |  |  or   |\n      #    |           |          |\n      #\n      if (mid$最高>=right$最高 & mid$最低 <= right$最低) { # mid include right\n        mid$最高 <- right$最高\n        flog.debug(paste(\"delete\",right$日期,\"data\"))\n        data[j,2:ncol(data)] <- NA\n        j <- j + 1\n      } else if (mid$最高<right$最高 & mid$最低 > right$最低) { # right include mid\n        right$最高 <- mid$最高\n        flog.debug(paste(\"delete\",mid$日期,\"data\"))\n        data[i,2:ncol(data)] <- NA\n        i <- j\n        j <- j + 1\n      } else {\n        p <- i\n        i <- j\n        j <- j + 1\n      }\n    } else { #if (left$最低 < mid$最低) \n      # like\n      #                          |\n      #    | | or   | | or    |  |  or    |\n      #  | |      |   |    |  |        |  |  |\n      #  |        |        |           |     |\n      #\n      if (mid$最高>=right$最高 & mid$最低 <= right$最低) { # mid include right\n        mid$最低 <- right$最低\n        flog.debug(paste(\"delete\",right$日期,\"data\"))\n        data[j,2:ncol(data)] <- NA\n        j <- j + 1\n      } else if (mid$最高<right$最高 & mid$最低 > right$最低) { # right include mid\n        right$最低 <- mid$最低\n        flog.debug(paste(\"delete\",mid$日期,\"data\"))\n        data[i,2:ncol(data)] <- NA\n        i <- j\n        j <- j + 1\n      } else {\n        p <- i\n        i <- j\n        j <- j + 1\n      }      \n    }  \n  }\n\n  return(na.omit(data))\n}\n\n\n\ndrawKline <- function(data) {\n  data <- data[,-ncol(data)]\n  data$日期 <- as.Date(data$日期,format=\"%Y%m%d\")\n  x <- xts(as.matrix(data[,2:ncol(data)]),data$日期)\n  colnames(x) <- c('Open','High','Low','Close','Volume')\n  #candleChart(x,TA=NULL)\n  chart_Series(x, type = \"candlesticks\" ) \n}\n\n\n\n",
    "created" : 1443540544015.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2491212578",
    "id" : "E8D3102B",
    "lastKnownWriteTime" : 1445260760,
    "path" : "C:/xtang/workspace/mystockanalysis/analysisRXSJ.R",
    "project_path" : "analysisRXSJ.R",
    "properties" : {
    },
    "relative_order" : 0,
    "source_on_save" : true,
    "type" : "r_source"
}